<!DOCTYPE html>
<html>
<head>
    <title>Flappy Bird - Fixed Gaps</title>
    <style>
        canvas {
            border: 1px solid black;
            cursor: pointer;
        }
        body {
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            margin: 0;
            background-color: #333;
            touch-action: manipulation;
            position: relative;
            font-family: Arial, sans-serif;
        }
        .game-button {
            position: absolute;
            cursor: pointer;
            display: none;
            image-rendering: pixelated;
            object-fit: contain;
            z-index: 2;
        }
        #leaderboard {
            width: 200px;
            height: 100px;
            top: 20px;
            left: 20px;
        }
        #restartBtn {
            width: 100px;
            height: 100px;
            left: 50%;
            transform: translateX(-50%);
            bottom: 100px;
        }
        #addToLeaderboard {
            width: 170px;
            height: 100px;
            left: 50%;
            transform: translateX(-50%);
            bottom: 170px;
        }
        #leaderboardPanel {
            display: none;
            position: absolute;
            background: rgba(0,0,0,0.9);
            color: white;
            padding: 20px;
            border-radius: 10px;
            max-height: 60vh;
            overflow-y: auto;
            width: 200px;
            left: 20px;
            top: 70px;
            z-index: 3;
        }
        #nameInput {
            position: absolute;
            display: none;
            background: rgba(0,0,0,0.9);
            padding: 20px;
            color: white;
            border-radius: 10px;
            text-align: center;
            z-index: 3;
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%);
        }
        #nameInput input {
            margin: 10px 0;
            padding: 8px;
            width: 150px;
            border: none;
            border-radius: 4px;
        }
        #nameInput button {
            background: #4CAF50;
            border: none;
            padding: 8px 15px;
            color: white;
            cursor: pointer;
            border-radius: 4px;
            margin-top: 10px;
        }
        .score-container {
            position: absolute;
            top: 20px;
            width: 100%;
            text-align: center;
            z-index: 2;
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas" width="400" height="600"></canvas>
    <div class="score-container">
        <div id="currentScore"></div>
        <div id="bestScore"></div>
    </div>
    <img id="leaderboard" src="leaderboard.png" class="game-button" alt="Leaderboard">
    <div id="leaderboardPanel"></div>
    <div id="nameInput">
        <input type="text" placeholder="Your name" id="playerName" maxlength="15">
        <button onclick="submitScore()">Submit</button>
    </div>
    <img id="restartBtn" src="restart.png" class="game-button" alt="Restart">
    <img id="addToLeaderboard" src="add to leaderboard.png" class="game-button" alt="Add to Leaderboard">

    <audio id="wingSound" src="wing.wav"></audio>
    <audio id="hitSound" src="hit.wav"></audio>
    <audio id="pointSound" src="point.wav"></audio>
    <audio id="dieSound" src="die.wav"></audio>
    <audio id="swooshSound" src="swoosh.wav"></audio>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const leaderboardBtn = document.getElementById('leaderboard');
        const leaderboardPanel = document.getElementById('leaderboardPanel');
        const nameInput = document.getElementById('nameInput');
        const restartBtn = document.getElementById('restartBtn');
        const addToLeaderboardBtn = document.getElementById('addToLeaderboard');
        const currentScoreElement = document.getElementById('currentScore');
        const bestScoreElement = document.getElementById('bestScore');

        // Game constants
        const GRAVITY = 1400;
        const JUMP_FORCE = -400;
        const PIPE_WIDTH = 60;
        const FLASH_DURATION = 0.3;
        const BASE_SCROLL_SPEED = 80;
        const MIN_GAP = 160; // Increased minimum gap
        const BASE_GAP = 200;

        // Game state
        let gameState = {
            bird: {
                x: 130,
                y: 280,
                velocity: 0,
                width: 40,
                height: 30,
                frame: 0,
                rotation: 0,
                sprites: [
                    new Image(),
                    new Image(),
                    new Image()
                ]
            },
            pipes: [],
            score: 0,
            bestScore: parseInt(localStorage.getItem('bestScore')) || 0,
            gameOver: false,
            started: false,
            baseOffset: 0,
            lastPipeTime: 0,
            numbers: [],
            baseHeight: 112,
            lastTime: performance.now(),
            flashTime: 0,
            hitGround: false,
            crashRotation: 0,
            scrollSpeed: 120
        };

        // Leaderboard data
        let leaderboard = JSON.parse(localStorage.getItem('leaderboard')) || [];

        // Load assets
        const assets = {
            background: new Image(),
            base: new Image(),
            gameOverImg: new Image(),
            pipeTop: new Image(),
            pipeBottom: new Image()
        };

        // Load images
        assets.background.src = 'background-day.png';
        assets.base.src = 'base.png';
        assets.gameOverImg.src = 'gameover.png';
        assets.pipeTop.src = 'pipe-green downwords.png';
        assets.pipeBottom.src = 'pipe-green upwords.png';
        gameState.bird.sprites[0].src = 'bluebird-upflap.png';
        gameState.bird.sprites[1].src = 'bluebird-midflap.png';
        gameState.bird.sprites[2].src = 'bluebird-downflap.png';

        // Load number images (0-9)
        for (let i = 0; i < 10; i++) {
            const img = new Image();
            img.src = `${i}.png`;
            gameState.numbers.push(img);
        }

        // Input handling
        function handleInput(e) {
            if (e) e.preventDefault();
            if (gameState.gameOver) return;
            
            if (!gameState.started) {
                gameState.started = true;
                document.getElementById('swooshSound').play();
            }
            
            gameState.bird.velocity = JUMP_FORCE;
            document.getElementById('wingSound').play();
        }

        // Event listeners
        canvas.addEventListener('mousedown', handleInput);
        canvas.addEventListener('touchstart', handleInput);
        document.addEventListener('keydown', (e) => {
            if (e.code === 'Space') handleInput(e);
        });

        // Leaderboard functionality
        leaderboardBtn.addEventListener('click', () => {
            leaderboardPanel.style.display = leaderboardPanel.style.display === 'block' ? 'none' : 'block';
            updateLeaderboardDisplay();
        });

        addToLeaderboardBtn.addEventListener('click', () => {
            nameInput.style.display = 'block';
        });

        function submitScore() {
            const name = document.getElementById('playerName').value.trim();
            if (name) {
                leaderboard.push({ 
                    name: name.substring(0, 15), 
                    score: gameState.score,
                    date: new Date().toISOString()
                });
                leaderboard.sort((a, b) => b.score - a.score || Date.parse(a.date) - Date.parse(b.date));
                leaderboard = leaderboard.slice(0, 10);
                localStorage.setItem('leaderboard', JSON.stringify(leaderboard));
                nameInput.style.display = 'none';
                updateLeaderboardDisplay();
            }
        }

        function updateLeaderboardDisplay() {
            leaderboardPanel.innerHTML = '<h3>Leaderboard</h3>';
            leaderboard.forEach((entry, index) => {
                leaderboardPanel.innerHTML += 
                    `${index + 1}. ${entry.name.padEnd(15, ' ').substring(0,15)}: ${entry.score}<br>`;
            });
        }

        // Game controls
        restartBtn.addEventListener('click', resetGame);

        function resetGame() {
            cancelAnimationFrame(animationFrameId);
            gameState = {
                ...gameState,
                bird: {
                    ...gameState.bird,
                    x: 130,
                    y: 280,
                    velocity: 0,
                    rotation: 0
                },
                pipes: [],
                score: 0,
                gameOver: false,
                started: false,
                baseOffset: 0,
                lastPipeTime: 0,
                flashTime: 0,
                hitGround: false,
                crashRotation: 0,
                scrollSpeed: 120
            };
            document.querySelectorAll('.game-button').forEach(btn => btn.style.display = 'none');
            nameInput.style.display = 'none';
            leaderboardBtn.style.display = 'block';
            document.querySelectorAll('audio').forEach(audio => {
                audio.pause();
                audio.currentTime = 0;
            });
            animationFrameId = requestAnimationFrame(gameLoop);
        }

        function positionElements() {
            const canvasRect = canvas.getBoundingClientRect();
            restartBtn.style.left = `${canvasRect.left + canvas.width/2 - 70}px`;
            restartBtn.style.top = `${canvasRect.top + canvas.height - 230}px`;
            addToLeaderboardBtn.style.left = `${canvasRect.left + canvas.width/2 - -4}px`;
            addToLeaderboardBtn.style.top = `${canvasRect.top + canvas.height - 170}px`;
        }

        function createPipe() {
            const scoreBasedModifier = Math.min(Math.floor(gameState.score / 5), 10);
            const dynamicGap = Math.max(MIN_GAP, BASE_GAP - scoreBasedModifier * 8);
            const minHeight = 80;
            const maxHeight = canvas.height - dynamicGap - minHeight - gameState.baseHeight;
            const height = Math.random() * (maxHeight - minHeight) + minHeight;
            const angle = Math.min(scoreBasedModifier * 3, 30) * (Math.random() < 0.5 ? -1 : 1);

            return {
                x: canvas.width + 50,
                topHeight: height,
                bottomHeight: canvas.height - height - dynamicGap - gameState.baseHeight,
                passed: false,
                width: PIPE_WIDTH,
                angle: angle,
                gap: dynamicGap
            };
        }

        function update(deltaTime) {
            if (!gameState.gameOver) {
                gameState.baseOffset = (gameState.baseOffset + BASE_SCROLL_SPEED * deltaTime) % (assets.base.naturalWidth || 336);
            }
            
            gameState.bird.frame = (gameState.bird.frame + deltaTime * 10) % 3;

            if (gameState.gameOver) {
                if (gameState.flashTime > 0) {
                    gameState.flashTime = Math.max(0, gameState.flashTime - deltaTime);
                }
                
                if (!gameState.hitGround) {
                    gameState.bird.velocity += GRAVITY * deltaTime * 2;
                    gameState.bird.y += gameState.bird.velocity * deltaTime;
                    gameState.crashRotation += 5 * deltaTime;

                    if (gameState.bird.y + gameState.bird.height > canvas.height - gameState.baseHeight) {
                        gameState.hitGround = true;
                        gameState.bird.rotation = 90;
                        restartBtn.style.display = 'block';
                        addToLeaderboardBtn.style.display = 'block';
                        positionElements();
                    }
                }
                return;
            }

            if (!gameState.started) return;

            // Bird physics
            gameState.bird.velocity += GRAVITY * deltaTime;
            gameState.bird.y += gameState.bird.velocity * deltaTime;
            gameState.bird.rotation = Math.min(Math.max(gameState.bird.velocity * 0.1, -25), 25);

            // Pipe generation
            if (performance.now() - gameState.lastPipeTime > 1500) {
                gameState.pipes.push(createPipe());
                gameState.lastPipeTime = performance.now();
            }

            // Pipe updates
            gameState.pipes.forEach(pipe => {
                pipe.x -= gameState.scrollSpeed * deltaTime;

                // Score counting
                if (!pipe.passed && pipe.x + pipe.width < gameState.bird.x) {
                    gameState.score++;
                    if (gameState.score % 5 === 0) {
                        gameState.scrollSpeed += 8;
                    }
                    document.getElementById('pointSound').play();
                    pipe.passed = true;
                    
                    // Update best score
                    if (gameState.score > gameState.bestScore) {
                        gameState.bestScore = gameState.score;
                        localStorage.setItem('bestScore', gameState.bestScore);
                        drawBestScore();
                    }
                }

                // Collision detection
                if (pipe.x + pipe.width > 0 && pipe.x < canvas.width) {
                    const birdRight = gameState.bird.x + gameState.bird.width;
                    const birdBottom = gameState.bird.y + gameState.bird.height;

                    // Basic collision detection with padding
                    const collisionPadding = 5;
                    if (gameState.bird.x + collisionPadding < pipe.x + pipe.width - collisionPadding &&
                        birdRight - collisionPadding > pipe.x + collisionPadding &&
                        (gameState.bird.y + collisionPadding < pipe.topHeight ||
                         birdBottom - collisionPadding > canvas.height - pipe.bottomHeight - gameState.baseHeight)) {
                        gameOver();
                    }
                }
            });

            gameState.pipes = gameState.pipes.filter(pipe => pipe.x + pipe.width > 0);

            // Ground collision
            if (gameState.bird.y + gameState.bird.height > canvas.height - gameState.baseHeight) {
                gameOver();
            }
        }

        function gameOver() {
            if (!gameState.gameOver) {
                gameState.gameOver = true;
                gameState.flashTime = FLASH_DURATION;
                gameState.crashRotation = gameState.bird.rotation;
                document.getElementById('hitSound').play();
                document.getElementById('dieSound').play();
                drawBestScore();
            }
        }

        function drawScore() {
            const scoreStr = gameState.score.toString();
            currentScoreElement.innerHTML = '';
            for (let digit of scoreStr) {
                const img = document.createElement('img');
                img.src = `${digit}.png`;
                img.style.width = '24px';
                img.style.height = '36px';
                img.style.display = 'inline-block';
                currentScoreElement.appendChild(img);
            }
        }

        function drawBestScore() {
            const bestStr = gameState.bestScore.toString();
            bestScoreElement.innerHTML = '';
            for (let digit of bestStr) {
                const img = document.createElement('img');
                img.src = `${digit}.png`;
                img.style.width = '24px';
                img.style.height = '36px';
                img.style.display = 'inline-block';
                bestScoreElement.appendChild(img);
            }
        }

        function drawBird() {
            ctx.save();
            ctx.translate(
                gameState.bird.x + gameState.bird.width/2,
                gameState.bird.y + gameState.bird.height/2
            );
            ctx.rotate(gameState.bird.rotation * Math.PI / 180);
            ctx.drawImage(
                gameState.bird.sprites[Math.floor(gameState.bird.frame)],
                -gameState.bird.width/2,
                -gameState.bird.height/2,
                gameState.bird.width,
                gameState.bird.height
            );
            ctx.restore();
        }

        function drawBase() {
            const baseY = canvas.height - gameState.baseHeight;
            const patternWidth = assets.base.naturalWidth || 336;
            
            for (let x = -gameState.baseOffset; x < canvas.width; x += patternWidth) {
                ctx.drawImage(assets.base, x, baseY);
            }
        }

        function drawPipes() {
            gameState.pipes.forEach(pipe => {
                // Top pipe with proper height
                ctx.save();
                ctx.translate(pipe.x + PIPE_WIDTH/2, pipe.topHeight);
                ctx.rotate(pipe.angle * Math.PI / 180);
                ctx.drawImage(
                    assets.pipeTop,
                    -PIPE_WIDTH/2,
                    -pipe.topHeight,
                    PIPE_WIDTH,
                    pipe.topHeight
                );
                ctx.restore();

                // Bottom pipe with proper height
                ctx.save();
                ctx.translate(
                    pipe.x + PIPE_WIDTH/2,
                    canvas.height - pipe.bottomHeight - gameState.baseHeight
                );
                ctx.rotate(-pipe.angle * Math.PI / 180);
                ctx.drawImage(
                    assets.pipeBottom,
                    -PIPE_WIDTH/2,
                    0,
                    PIPE_WIDTH,
                    pipe.bottomHeight
                );
                ctx.restore();
            });
        }

        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.drawImage(assets.background, 0, 0, canvas.width, canvas.height);

            drawPipes();
            if (assets.base.complete) drawBase();

            if (gameState.flashTime > 0) {
                const flashAlpha = Math.min(1, gameState.flashTime / FLASH_DURATION * 2);
                ctx.fillStyle = `rgba(255, 255, 255, ${flashAlpha})`;
                ctx.fillRect(0, 0, canvas.width, canvas.height);
            }

            if (gameState.gameOver) {
                ctx.save();
                ctx.translate(
                    gameState.bird.x + gameState.bird.width/2,
                    gameState.bird.y + gameState.bird.height/2
                );
                ctx.rotate((gameState.hitGround ? 90 : gameState.crashRotation) * Math.PI / 180);
                ctx.drawImage(
                    gameState.bird.sprites[1],
                    -gameState.bird.width/2,
                    -gameState.bird.height/2,
                    gameState.bird.width,
                    gameState.bird.height
                );
                ctx.restore();

                ctx.drawImage(assets.gameOverImg, canvas.width/2 - 100, 150, 200, 200);
            } else {
                drawBird();
            }

            drawScore();
        }

        let animationFrameId;
        function gameLoop(currentTime) {
            const deltaTime = (currentTime - gameState.lastTime) / 1000;
            gameState.lastTime = currentTime;

            try {
                update(deltaTime);
                draw();
            } catch (error) {
                console.error('Game error:', error);
                return;
            }

            animationFrameId = requestAnimationFrame(gameLoop);
        }

        // Initialize game
        assets.base.onload = () => {
            gameState.baseHeight = assets.base.naturalHeight;
            leaderboardBtn.style.display = 'block';
            drawBestScore();
            positionElements();
            animationFrameId = requestAnimationFrame(gameLoop);
        };

        updateLeaderboardDisplay();
    </script>
</body>
</html>